Начнем с инициализации: 
_joined - флаг наличия в группе
T = 5 - интервал пинга
S = 3 - множитель для таймаута ожидания ответа
K = 2 - количество ретрансляторов для переотправки пингов
SAMPLE_SIZE = 20 - размер выборки для передачи в CRDT
_time - время процесса
_added_members - словарь добавленных участников
_removed_members - словарь удаленных участников
_waiting_answer - статусы ожидания ответов
_active - множество активных участников
_generation - текущее поколение процесса

На локальном сообщении:

JOIN с собственным ID создает новую группу
JOIN с чужим ID присоединяется к существующей группе через seed-узел
LEAVE выходит из группы
GET_MEMBERS возвращает локальный список активных участников

Теперь рассмотрим создание/присоединение в группы.
В _create_group все в целом понятно, не забываем запустить периодические пинги для проверки состояния. 

Что происходит в mark_added - добавляем айди процесса в CRDT и разрешаем конфликт с его удалением (если удаление было раньше - удаляем его), 
обновляем логическое время, помечаем айдишник, как активный.

Теперь присоединение к группе - проверяем, не присоединены ли уже, устанавливаем флаг участия, добавляем себя с ts = -1 (чтобы затем
без проблем синхронизироваться с данными сида). После этого отправляем K пингов seed-узлу для синхронизации и не забываем запустить 
периодические пинги.

Рассмотрим теперь что происходит на стороне сида на пинге. Достаем данные из сообщения, сливаем CRDT данные. Обрабатываем отправителя (должен
быть в группе) и отправляем респонс.

Теперь рассмотрим что происходит с обработкой респонсов на пинги. Аналогично достаем данные из сообщения, сливаем CRDT данные, сбрасываем
статус ожидания, обновляем активность отправителя.

Теперь посмотрим что происходит в периодических пингах. Формируем список кандидатов для проверки, таргет - случайный процесс из кандидатов.
устанавливаем статус ожидания (0 - ничего не ждет, 1 - пинг отправили, ждем ответ, 2 - не получили ответ, отправили через ретрансляторы) и
отправляем пинг со случайными выборками размера SAMPLE_SIZE = 20. Ну еще устанавливаем таймер для ожидания ответа.

Когда срабатывает таймер! Извлекаем айди из имени таймера, при статусе ожидания ответа = 1 - пробуем отправить пинг через ретрансляторов, 
иначе помечаем цель, как отказавшую. 

В целом, на этом вроде как все. Система успешно определяет и удаляет упавшие процессы через механизм таймаутов пингов, используем CRDT логику
для разрешения конфликтов по добавлению/удалению процессов. Не проходит только тесты с отказами сети, возможно, из-за случайного выбора таргета,
не учитывая историю сетевой доступности.
